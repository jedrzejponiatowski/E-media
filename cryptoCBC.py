import crypto as c

the_unspeakable = ''

# lets operate on the same premise - that we are gettin a big string of utf8 chars as msg
def encryptLargeFileCBC(msg, publicKey): # msg here is in utf8 characters
    bits = c.getMaxBitsDataSize(publicKey) 
    asciiMsg = c.msgToAsciiValue(msg)
    blocks = c.splitToBlocks(asciiMsg, bits) # one block looks like this: "097"
    iv = "1001110100011011111101010001010101001110" # 40

    encrypted_msg = ''

    for block in blocks: # one block is a string of utf8 cahr values
        block_to_int = int(block)
        print("block_to_int:", block_to_int, " block:", block)
        iv = iv[ :len(bin(block_to_int))-2 ] # cut iv's length to match the binary representation of block. -2 to skip the '0b' prefix
        #lens of iv and block_to_bin might be missmatched
        xor = int(iv, 2) ^ int(block_to_int) # perform the XOR operation, result is in base-10
        # xor = str(xor).zfill( max(len(iv), len(block_to_bin)-2) ) # -2 is skipping 0b

        # different xors have different ammounts of digits - roughly from 3 to 5.
        # The length of the resullting xor is different from its expected lengh

        print("xor: ", xor)
        enc_block = str(c.encryptBlock(xor, publicKey)) # encrypt a single block
        print("enc_block:", enc_block)

        iv = str(bin(int(enc_block)))[2:].ljust(40, "0") # update IV with the result of encription, skip 0b prefix
        # iv might become shorter than the next block
        print("Iv: ", iv)
        encrypted_msg = encrypted_msg + (enc_block + '\n')
        # those '\n' were added to mimic the behavior of encryptBlockMessage 
        the_unspeakable = iv
    return encrypted_msg.rstrip('\n')
        
def decryptLargeFileCBC(msg, privateKey):
    blocks = msg.split(b'\n') # should be "raw" bytes, like in the original function

    # iv = "1001110100011011111101010001010101001110"
    iv = the_unspeakable
    # maybe initial iv has to be the same as the iv generated by last block in encryption?
    next_iv = ''
    decrypted_message = ''

    for block in blocks:
        next_iv = bin(int.from_bytes(block))
        decrypted_block = c.decryptBlock(int(block), privateKey)

        dec_block_to_bin = bin(int(decrypted_block))
        iv = iv[ :len(dec_block_to_bin)-2]
        xor = int(iv, 2) ^ int(dec_block_to_bin, 2)

        decrypted_message = decrypted_message + c.asciiToText(str(xor))
        iv = next_iv

    return decrypted_message

"""probably made an error during one of the conversions. It makes no sense taht int(block) doesnt
go through.

Compare types between both modes of encoding"""